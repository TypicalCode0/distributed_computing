# Отчет по лабораторной работе №2
## Задание 3: Реализация и исследование блокировок чтения-записи (Read-Write Lock)

### 1. Постановка задачи
Целью работы являлось создание собственной реализации примитива синхронизации `rwlock` (блокировка чтения-записи) с использованием мьютексов и условных переменных стандарта POSIX (`pthreads`). Необходимо было сравнить производительность собственной реализации (`Custom RWLock`) со стандартной библиотечной реализацией (`pthread_rwlock`) на задаче параллельной обработки односвязного списка.

### 2. Детали реализации (Custom RWLock)
Была разработана структура `my_rwlock_t`, содержащая:
*   `pthread_mutex_t mtx` - для защиты внутренних счетчиков.
*   `pthread_cond_t read_cond`, `write_cond` - условные переменные для ожидания читателей и писателей.
*   Счетчики: активных читателей, ожидающих читателей, ожидающих писателей и флаг активности писателя.

**Алгоритм работы:**
В реализации заложен механизм **приоритета писателей** (Writer Priority).
*   **Чтение (`rdlock`):** Поток может захватить блокировку, только если нет активного писателя **И** нет ожидающих писателей (`waiting_writers == 0`). Это предотвращает голодание писателей (write starvation), но снижает параллелизм читателей при высокой нагрузке.
*   **Запись (`wrlock`):** Поток ожидает, пока освободятся все активные читатели и писатель.
*   **Освобождение (`unlock`):** Если уходит писатель, он будит других писателей (если есть), иначе читателей. Если уходит читатель, и он был последним, он будит писателей.

### 3. Методика тестирования
*   **Тестовая задача:** Операции над односвязным списком: `Member` (поиск), `Insert` (вставка), `Delete` (удаление).
*   **Нагрузка:**
    *   Общее количество операций: 100,000 (распределяются между потоками).
    *   Соотношение операций: **80% чтение**, **20% запись** (вставка + удаление).
    *   Список предварительно заполняется 1000 элементами.
*   **Оборудование/Среда**: Запускал на виртуальной машине VMware Workstation с ubuntu 24 (x86_64) (основаная операционная система windows 11 (тоже x86_64)).
*   **Измеряемая величина:** Время выполнения всех операций.

### 4. Результаты и анализ графика
![plot](task_3/rwlock_comparison.png)
На представленном графике отображена зависимость времени выполнения от количества потоков (1, 2, 4, 8, 12, 16).

#### Наблюдения:

1.  **Малое количество потоков (1-4 потока):**
    *   **Custom RWLock (Оранжевая линия):** Показывает лучшую производительность, чем библиотечная версия. При 2-х потоках время ~1.1 сек против ~2.8 сек у библиотеки. При 4-х потоках - ~2.0 сек.
    *   **Library RWLock (Синяя линия):** Резко замедляется уже при переходе от 1 к 2 потокам и выходит на плато (~2.8 - 3.0 сек).
    *   **Причина:** Собственная реализация на базе мьютекса и условной переменной оказывается "легче" стандартной реализации `pthread_rwlock` при низкой конкуренции. Библиотечная реализация, вероятно, имеет более сложную логику проверки справедливости (fairness) и защиты от инверсии приоритетов, что создает накладные расходы.

2.  **Точка перегиба (между 4 и 8 потоками):**
    *   Графики пересекаются. Производительность собственной реализации начинает резко падать (время растет).

3.  **Высокое количество потоков (8-16 потоков):**
    *   **Custom RWLock:** Время выполнения линейно растет, достигая ~4.5 сек на 16 потоках.
    *   **Library RWLock:** Время остается стабильным (~3.0 сек), библиотека справляется с нагрузкой лучше.
    *   **Анализ причин (Ключевой момент):**
        Падение производительности собственной реализации объясняется выбранной стратегией **Приоритета Писателей**.
        *   В тесте 20% операций - это запись. Это достаточно высокий процент.
        *   В коде `rdlock` есть проверка: `while (rw->writer_active || rw->waiting_writers > 0)`.
        *   Как только появляется *хотя бы один* желающий писать, **все** новые читатели блокируются.
        *   При 16 потоках вероятность того, что кто-то хочет писать, очень высока. В итоге параллелизм чтения (основная цель RWLock) убивается: потоки выстраиваются в очередь, и RWLock фактически вырождается в (или даже работает хуже) обычный Mutex.
        *   Библиотечная реализация (`pthread_rwlock`), скорее всего, использует адаптивный подход или приоритет читателей (Reader Priority), позволяя читателям заходить в критическую секцию, даже если есть ожидающие писатели, что выгоднее при нагрузке 80% на чтение.

### 5. Выводы

1.  **Эффективность на малой нагрузке:** Собственная упрощенная реализация RWLock оказалась эффективнее стандартной на малом числе потоков (до 4-6) за счет меньших накладных расходов (overhead) на системные вызовы и проверки безопасности.
2.  **Проблема масштабируемости:** На большом числе потоков собственная реализация проигрывает. Это демонстрирует классический компромисс (trade-off) в синхронизации: **Приоритет писателей** гарантирует свежесть данных, но при частых записях (20%) блокирует параллельное чтение, снижая общую пропускную способность системы.
3.  **Стабильность библиотеки:** Стандартная библиотека `pthreads` обеспечивает предсказуемое время выполнения вне зависимости от роста числа потоков, эффективно утилизируя ресурсы при высокой конкуренции.

**Итог:** Реализованный механизм работает корректно, но для нагрузок с высокой интенсивностью записи и большим количеством потоков требует оптимизации стратегии планирования (например, переход к справедливой очереди или приоритету читателей).
